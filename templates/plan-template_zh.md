# 实现计划: [功能]

**分支**: `[###-功能名称]` | **日期**: [日期] | **规格**: [链接]
**输入**: 来自 `/specs/[###-功能名称]/spec.md` 的功能规格

## 执行流程 (/plan 命令范围)
```
1. 从输入路径加载功能规格
   → 如果未找到: 错误 "在 {path} 处没有功能规格"
2. 填写技术背景 (扫描 NEEDS CLARIFICATION)
   → 从上下文中检测项目类型 (web=前端+后端, mobile=应用+api)
   → 根据项目类型设置结构决策
3. 评估下面的章程检查部分
   → 如果存在违规: 在复杂度追踪中记录
   → 如果无法提供理由: 错误 "请先简化方法"
   → 更新进度追踪: 初始章程检查
4. 执行阶段 0 → research.md
   → 如果仍有 NEEDS CLARIFICATION: 错误 "请解决未知问题"
5. 执行阶段 1 → contracts, data-model.md, quickstart.md, 特定于代理的模板文件 (例如, Claude Code 的 `CLAUDE.md`, GitHub Copilot 的 `.github/copilot-instructions.md`, 或 Gemini CLI 的 `GEMINI.md`)。
6. 重新评估章程检查部分
   → 如果有新的违规: 重构设计, 返回阶段 1
   → 更新进度追踪: 设计后章程检查
7. 规划阶段 2 → 描述任务生成方法 (不要创建 tasks.md)
8. 停止 - 准备好执行 /tasks 命令
```

**重要提示**: /plan 命令在第 7 步停止。阶段 2-4 由其他命令执行:
- 阶段 2: /tasks 命令创建 tasks.md
- 阶段 3-4: 实现执行 (手动或通过工具)

## 摘要
[从功能规格中提取: 主要需求 + 来自研究的技术方法]

## 技术背景
**语言/版本**: [例如, Python 3.11, Swift 5.9, Rust 1.75 或 需要澄清]  
**主要依赖**: [例如, FastAPI, UIKit, LLVM 或 需要澄清]  
**存储**: [如果适用, 例如, PostgreSQL, CoreData, 文件 或 不适用]  
**测试**: [例如, pytest, XCTest, cargo test 或 需要澄清]  
**目标平台**: [例如, Linux 服务器, iOS 15+, WASM 或 需要澄清]
**项目类型**: [单一/web/移动 - 决定源码结构]  
**性能目标**: [领域特定, 例如, 1000 请求/秒, 10k 行/秒, 60 fps 或 需要澄清]  
**约束**: [领域特定, 例如, <200ms p95, <100MB 内存, 可离线 或 需要澄清]  
**规模/范围**: [领域特定, 例如, 10k 用户, 1M 行代码, 50 个屏幕 或 需要澄清]

## 章程检查
*门禁: 必须在阶段 0 研究之前通过。在阶段 1 设计之后重新检查。*

**简单性**:
- 项目数量: [#] (最多 3 个 - 例如, api, cli, tests)
- 直接使用框架? (没有包装类)
- 单一数据模型? (除非序列化不同，否则没有 DTO)
- 避免设计模式? (没有经过验证的需求，不使用 Repository/UoW)

**架构**:
- 每个功能都作为库? (没有直接的应用程序代码)
- 列出的库: [每个库的名称 + 用途]
- 每个库的 CLI: [带有 --help/--version/--format 的命令]
- 库文档: 是否计划使用 llms.txt 格式?

**测试 (不可协商)**:
- 是否强制执行红-绿-重构循环? (测试必须先失败)
- Git 提交是否在实现之前显示测试?
- 是否严格遵循顺序: 契约→集成→端到端→单元?
- 是否使用真实依赖? (实际的数据库，而不是模拟对象)
- 是否为新库、契约变更、共享模式进行集成测试?
- 禁止: 在测试前实现, 跳过红色阶段

**可观察性**:
- 是否包含结构化日志?
- 前端日志 → 后端? (统一流)
- 错误上下文是否充分?

**版本控制**:
- 是否分配了版本号? (主版本.次版本.修订版本)
- 每次变更都增加修订版本号?
- 是否处理了重大变更? (并行测试, 迁移计划)

## 项目结构

### 文档 (此功能)
```
specs/[###-功能]/
├── plan.md              # 此文件 (/plan 命令输出)
├── research.md          # 阶段 0 输出 (/plan 命令)
├── data-model.md        # 阶段 1 输出 (/plan 命令)
├── quickstart.md        # 阶段 1 输出 (/plan 命令)
├── contracts/           # 阶段 1 输出 (/plan 命令)
└── tasks.md             # 阶段 2 输出 (/tasks 命令 - 不是由 /plan 创建)
```

### 源代码 (仓库根目录)
```
# 选项 1: 单一项目 (默认)
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# 选项 2: Web 应用程序 (当检测到 "前端" + "后端" 时)
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# 选项 3: 移动应用 + API (当检测到 "iOS/Android" 时)
api/
└── [同上面的后端]

ios/ 或 android/
└── [特定于平台的结构]
```

**结构决策**: [默认为选项 1，除非技术背景指明是 web/移动应用]

## 阶段 0: 大纲与研究
1. **从上面的技术背景中提取未知项**:
   - 对于每个 需要澄清 → 研究任务
   - 对于每个依赖 → 最佳实践任务
   - 对于每个集成 → 模式任务

2. **生成并派遣研究代理**:
   ```
   对于技术背景中的每个未知项:
     任务: "为 {功能上下文} 研究 {未知项}"
   对于每个技术选择:
     任务: "在 {领域} 中寻找 {技术} 的最佳实践"
   ```

3. **在 `research.md` 中整合发现**，使用以下格式:
   - 决策: [选择了什么]
   - 理由: [为什么选择]
   - 考虑过的替代方案: [评估了哪些其他方案]

**输出**: research.md，其中所有 需要澄清 的问题都已解决

## 阶段 1: 设计与契约
*先决条件: research.md 已完成*

1. **从功能规格中提取实体** → `data-model.md`:
   - 实体名称, 字段, 关系
   - 来自需求中的验证规则
   - 如果适用，状态转换

2. **从功能需求生成 API 契约**:
   - 每个用户操作 → 一个端点
   - 使用标准的 REST/GraphQL 模式
   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`

3. **从契约生成契约测试**:
   - 每个端点一个测试文件
   - 断言请求/响应模式
   - 测试必须失败 (因为还没有实现)

4. **从用户故事中提取测试场景**:
   - 每个故事 → 一个集成测试场景
   - 快速入门测试 = 故事验证步骤

5. **增量更新代理文件** (O(1) 操作):
   - 为你的 AI 助手运行 `/scripts/update-agent-context.sh [claude|gemini|copilot]`
   - 如果文件已存在: 仅添加当前计划中的新技术
   - 保留标记之间的手动添加内容
   - 更新最近变更 (保留最近 3 个)
   - 保持在 150 行以下以提高令牌效率
   - 输出到仓库根目录

**输出**: data-model.md, /contracts/*, 失败的测试, quickstart.md, 特定于代理的文件

## 阶段 2: 任务规划方法
*本节描述 /tasks 命令将执行的操作 - 不要在 /plan 期间执行*

**任务生成策略**:
- 加载 `/templates/tasks-template.md` 作为基础
- 从阶段 1 的设计文档 (契约, 数据模型, 快速入门) 生成任务
- 每个契约 → 契约测试任务 [P]
- 每个实体 → 模型创建任务 [P] 
- 每个用户故事 → 集成测试任务
- 使测试通过的实现任务

**排序策略**:
- TDD 顺序: 测试先于实现
- 依赖顺序: 模型先于服务，服务先于 UI
- 标记 [P] 表示可并行执行 (独立文件)

**预估输出**: 在 tasks.md 中有 25-30 个编号、排序的任务

**重要提示**: 此阶段由 /tasks 命令执行, 而不是 /plan

## 阶段 3+: 未来实现
*这些阶段超出了 /plan 命令的范围*

**阶段 3**: 任务执行 (/tasks 命令创建 tasks.md)  
**阶段 4**: 实现 (遵循章程原则执行 tasks.md)  
**阶段 5**: 验证 (运行测试, 执行 quickstart.md, 性能验证)

## 复杂度追踪
*仅当章程检查有必须说明理由的违规时填写*

| 违规 | 为何需要 | 更简单的替代方案因何被拒绝 |
|-----------|------------|-------------------------------------|
| [例如, 第 4 个项目] | [当前需求] | [为什么 3 个项目不够] |
| [例如, 仓库模式] | [具体问题] | [为什么直接访问数据库不够] |


## 进度追踪
*此清单在执行流程中更新*

**阶段状态**:
- [ ] 阶段 0: 研究完成 (/plan 命令)
- [ ] 阶段 1: 设计完成 (/plan 命令)
- [ ] 阶段 2: 任务规划完成 (/plan 命令 - 仅描述方法)
- [ ] 阶段 3: 任务已生成 (/tasks 命令)
- [ ] 阶段 4: 实现完成
- [ ] 阶段 5: 验证通过

**门禁状态**:
- [ ] 初始章程检查: 通过
- [ ] 设计后章程检查: 通过
- [ ] 所有 需要澄清 的问题已解决
- [ ] 复杂度偏差已记录

---
*基于章程 v2.1.1 - 参见 `/memory/constitution.md`*
